# このファイルで untyped が多用されている主な理由：
#
# ActiveRecordやRailsの動的性質
#   - ActiveRecordは動的にメソッドや属性が追加されるため、厳密な型付けが困難な箇所が多い。
#   - 代表的なメソッド（where, order, find など）は返り値が多様で、型を特定しづらい。
# 柔軟性・拡張性の担保
#   - Railsの柔軟なメタプログラミングや拡張性を損なわないため

interface _ApplicationRecord
  def save!: () -> void
end

interface _ApplicationRecordClass
  def where: (*untyped) -> untyped
  def last: () -> untyped
  def new: (*untyped, **untyped) -> untyped
  def order: (*untyped) -> untyped
  def limit: (*untyped) -> untyped
end

class ApplicationRecord < ActiveRecord::Base
  include _ApplicationRecord
  extend _ApplicationRecordClass
end


class PlayerHandState < ApplicationRecord
  include _ApplicationRecord
  extend _ApplicationRecordClass
  MAX_HAND_SIZE: Integer
  attr_accessor status: String
  attr_accessor current_rank: String
  attr_accessor current_turn: Integer
  attr_accessor hand_set: Array[String]
  def assign_hand_number_from_set: (untyped) -> void
  def self.find_current_session: () -> PlayerHandState?
end


class Event < ApplicationRecord
  include _ApplicationRecord
  extend _ApplicationRecordClass
  def self.maximum: (*untyped) -> untyped
  def self.exists?: (*untyped) -> untyped
  def self.create!: (*untyped) -> untyped
  attr_reader event_type: String
  attr_reader event_data: String
  attr_reader occurred_at: Time
  attr_reader version: Integer
end

class GameSetting
  MAX_HAND_SIZE: Integer
end

class History < ApplicationRecord
  extend _ApplicationRecordClass
  attr_accessor hand_set: Array[String]
  attr_accessor rank: Integer
  attr_accessor ended_at: Time
end

# HandSet本体
class HandSet
  MAX_HAND_SIZE: Integer
  attr_reader cards: Array[HandSet::Card]
  def self.build: (Array[HandSet::Card | _CardForQuery | _CardForCommand]) -> HandSet
  def self.valid_cards?: (Array[HandSet::Card]) -> bool
  def initialize: (Array[HandSet::Card]) -> void
  def rebuild_after_exchange: (_CardForCommand, _CardForCommand) -> HandSet
  def evaluate: () -> String
  def rank_name: () -> String
  def valid?: () -> bool
  def fetch_by_number: (Integer) -> HandSet::Card
  def include?: (HandSet::Card) -> bool  
  def self.build_card_from_string: (String) -> HandSet::Card
  def self.card?: (untyped) -> bool
  def self.rank_japanese_name: (String) -> String
  def self.build_card_for_command: (String) -> _CardForCommand
  def self.build_card_for_query: (String) -> _CardForQuery
  def apply_event_to_replay_hand: (Array[_CardForCommand] cards, _Event event) -> Array[_CardForCommand]
  def build_invalid_command_event_if_unexchangeable: (Array[_CardForCommand] cards) -> InvalidCommandEvent
end

class HandSet::Card
  include _CardForCommand
  include _CardForQuery
  VALID_SUITS: ::Array[String]
  VALID_RANKS: ::Array[String]

  def self.generate_available: (?Array[HandSet::Card]) -> Array[HandSet::Card]
  def initialize: (String) -> void
end




# HandSetの内部で使われるためrbsファイルでノイズにならないように分けてある
class HandSet
  module Rank
    HIGH_CARD: String
    ONE_PAIR: String
    TWO_PAIR: String
    THREE_OF_A_KIND: String
    STRAIGHT: String
    FLUSH: String
    FULL_HOUSE: String
    FOUR_OF_A_KIND: String
    STRAIGHT_FLUSH: String
    ROYAL_FLUSH: String
    ALL: Array[String]
    NAMES: Hash[String, String]
    def self.japanese_name: (String) -> String
  end

  class Evaluate
    def self.call: (Array[HandSet::Card] cards) -> String
    def call: (Array[HandSet::Card] cards) -> String
    def build_rank_checks_map: () -> Hash[String, ::Proc]
    def valid_hand?: (Array[HandSet::Card] cards) -> bool
    def straight_flush?: () -> bool
    def four_of_a_kind?: () -> bool
    def full_house?: () -> bool
    def flush?: () -> bool
    def straight?: () -> bool
    def three_of_a_kind?: () -> bool
    def two_pair?: () -> bool
    def one_pair?: () -> bool
    def rank_combinations: () -> untyped
    def suits: () -> Array[String]
    def rank_counts: () -> untyped
    def ranks: () -> Array[String]

    class RankCombinations
      def initialize: (untyped values) -> void
      def pair_count: () -> Integer
      def three_of_a_kind?: () -> bool
      def four_of_a_kind?: () -> bool
      def full_house?: () -> bool
    end
  end

  
end 