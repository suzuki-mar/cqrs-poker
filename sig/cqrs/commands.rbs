# エラーコード定義（許容される値を明示）
type command_error_code =
  :GAME_NOT_IN_PROGRESS |
  :GAME_ALREADY_ENDED |
  :GAME_NOT_FOUND |
  :INVALID_CARD |
  :CARD_NOT_FOUND |
  :EXCHANGE_LIMIT_EXCEEDED |
  :VALIDATION_ERROR |
  :UNKNOWN_COMMAND |
  :INVALID_SELECTION |
  :NO_CARDS_LEFT

type in_game_command = Commands::ExchangeCard | Commands::EndGame


interface _Command
  def class: () -> untyped
  def nil?: () -> bool
  def is_a?: (Class) -> bool
<<<<<<< HEAD
=======
  def game_number:() -> GameNumber?
>>>>>>> 3214f9b (リファクタ)
end

module Commands
  class GameStart
    include _Command
    def initialize: () -> void
  end

  class ExchangeCard
    include _Command
    attr_reader discarded_card: HandSet::Card
    def initialize: (HandSet::Card, GameNumber) -> void
  end

  class EndGame
    include _Command
    def initialize: (GameNumber) -> void
  end
end

module CommandErrors
  class VersionConflict
    attr_reader expected_version: Integer
    attr_reader actual_version: Integer
    def initialize: (Integer, Integer) -> void
  end

  class InvalidCommand
<<<<<<< HEAD
    attr_reader command: _Command
    attr_reader reason: String
    def initialize: (command: _Command, reason: String) -> void
=======
      GAME_NOT_IN_PROGRESS: command_error_code
      GAME_ALREADY_ENDED: command_error_code
      GAME_NOT_FOUND: command_error_code
  
      INVALID_CARD: command_error_code
      CARD_NOT_FOUND: command_error_code
      EXCHANGE_LIMIT_EXCEEDED: command_error_code
  
      VALIDATION_ERROR: command_error_code
  
      UNKNOWN_COMMAND: command_error_code
      INVALID_SELECTION: command_error_code
      NO_CARDS_LEFT: command_error_code
  
      attr_reader command: _Command
      attr_reader reason: String
      attr_reader error_code: command_error_code
      
      def initialize: (command: _Command, reason: String, error_code: command_error_code) -> void
>>>>>>> 3214f9b (リファクタ)
  end
end

interface _CommandHandler
  def initialize: (EventBus) -> void
  def handle: (_Command) -> CommandResult
  def append_to_aggregate_store: (_Event, _Command) -> CommandResult

end


module CommandHandlers
  class GameStart
    include _CommandHandler

    private
    attr_reader start_command: Commands::GameStart
    attr_reader event_bus:  EventBus
    attr_reader aggregate_store: Aggregates::Store
    def append_event_to_store!: (HandSet initial_hand) -> CommandResult
  end

  class InGame
    include _CommandHandler

    private
    attr_reader event_bus:  EventBus
    attr_reader aggregate_store: Aggregates::Store
<<<<<<< HEAD
    attr_reader exchange_command: Commands::ExchangeCard

    def append_event_to_store!: (HandSet::Card) -> CommandResult


    class ErrorResultBuilder
      def self.build_error_if_needed: (Commands::ExchangeCard, Aggregates::Store, Aggregates::BoardAggregate) -> CommandResult?
      def self.build_error_message_of_game_status_if_needed: (Aggregates::Store, Commands::ExchangeCard) -> String?
      def self.build_error_message_of_hand_state_in_hand_if_needed: (Aggregates::Store, HandSet::Card, Aggregates::BoardAggregate, Commands::ExchangeCard) -> String?
      def self.rebuild_hand_from_event: (Array[HandSet::Card], _Event, Aggregates::BoardAggregate) -> Array[HandSet::Card]
=======
    attr_reader command: in_game_command
    attr_accessor executor: _InGameExecutor

    def append_event_to_store!: (HandSet::Card) -> CommandResult

    def build_executor: -> _InGameExecutor

  end

  interface _InGameExecutor
    def initialize: () -> void

    def operate_board: (Aggregates::BoardAggregate) -> void

    def build_event: (in_game_command) -> _Event
  end

  module InGameExecutor
    class ExchangeCard
      include _InGameExecutor

      private
      attr_reader new_card: HandSet::Card
>>>>>>> 3214f9b (リファクタ)
    end
  end

  class EndGame
    include _CommandHandler

    private
    attr_reader event_bus:  EventBus
    attr_reader aggregate_store: Aggregates::Store
    attr_reader end_game_command: Commands::EndGame

    def validate_game_state: () -> CommandResult?
    def process_end_game: () -> CommandResult
    def append_event_to_store!: () -> CommandResult
    def build_error_result_if_needed: () -> CommandResult?
  end
end

module Aggregates
  class Store
<<<<<<< HEAD
    def next_available_version_for_game: (GameNumber) -> Integer
    def current_version_for_game: (GameNumber) -> Integer
    def exists_game?: (GameNumber) -> bool
=======


    def next_available_version_for_game: (GameNumber) -> Integer
    def current_version_for_game: (GameNumber) -> Integer
    def exists_game?: (GameNumber) -> bool
    def game_ended?:(GameNumber) -> bool
    def game_in_progress?: (GameNumber) -> bool
>>>>>>> 3214f9b (リファクタ)
    def append_event: (_Event, GameNumber) -> CommandResult
    def append_initial_event: (_Event, GameNumber) -> CommandResult
    def load_all_events_in_order: () -> Array[_Event]
    def latest_event: () -> _Event?
<<<<<<< HEAD
    def game_in_progress?: (GameNumber) -> bool
=======
>>>>>>> 3214f9b (リファクタ)
    def load_board_aggregate_for_current_state: () -> Aggregates::BoardAggregate

    private
    def persist_and_finalize_event: (_Event, GameNumber) -> CommandResult
    def valid_event_type?: (_Event | CommandErrors::InvalidCommand | CommandErrors::VersionConflict) -> bool
    def create_event_record!: (_Event, GameNumber) -> Event

    class EventBuilder
      MAPPINGS: Hash[String, untyped]

      def self.execute: (Event event_record) -> _Event

      private
      def self.raise_if_invalid_event_record: (Event event_record, Hash[String, untyped] maps) -> void
      def self.build_event: (Event event_record, Hash[String, untyped] maps) -> _Event
      def self.valid_event_type?: (untyped) -> bool
    end

    class ErrorResultBuilder
      def self.version_conflict: (GameNumber, Integer) -> CommandResult
      def self.validation_error: (ActiveRecord::RecordInvalid, _Command) -> CommandResult
    end
  end

  class BoardAggregate
    def apply: (_Event event) -> void
    def draw_initial_hand: () -> HandSet
    def draw: () -> HandSet::Card
    def drawable?: () -> bool
    def finish_game: () -> nil
    def build_cards_from_exchanged_event: (Array[HandSet::Card], CardExchangedEvent) -> Array[HandSet::Card]
  
    private
    attr_reader deck: Deck
    attr_reader trash: Trash
    attr_accessor game_started: bool
    def build_cards_from_event: (GameStartedEvent) -> Array[HandSet::Card]
  end

  class Deck
    attr_reader cards: Array[HandSet::Card]
    def draw_initial_hand: () -> HandSet
    def draw: () -> HandSet::Card
    def remove: (HandSet::Card card) -> void
    def has?: (HandSet::Card card) -> bool

    def remaining_count: () -> Integer
  
    private
    def generate_initial_cards: () -> Array[HandSet::Card]
  end

  class Trash
    def accept: (HandSet::Card card) -> void

    private
    attr_reader cards: Array[HandSet::Card]
  end
end

class CommandResult
  attr_reader event: _Event?

  type command_result_error = CommandErrors::InvalidCommand | CommandErrors::VersionConflict

  attr_reader error: (command_result_error)?
  def initialize: (?event: _Event?, ?error: command_result_error?) -> void
  def success?: () -> bool
  def failure?: () -> bool
  def self.invalid_command: (_Command, String, command_error_code) -> CommandResult
end

class CommandBus
  def initialize: (EventBus, Logger) -> void
  def execute: (_Command) -> CommandResult
  private
  type command_class = singleton(Commands::GameStart) | singleton(Commands::EndGame) | singleton(Commands::ExchangeCard)
  type command_handler = CommandHandlers::GameStart | CommandHandlers::EndGame | CommandHandlers::ExchangeCard


  def build_handler_map: () -> Hash[command_class, command_handler]
  def log_error_if_needed: (untyped) -> void
  attr_reader event_bus: EventBus
  attr_reader logger: Logger
end