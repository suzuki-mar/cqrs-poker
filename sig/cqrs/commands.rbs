# エラーコード定義（許容される値を明示）
type command_error_code =
  :GAME_NOT_IN_PROGRESS |
  :GAME_ALREADY_ENDED |
  :GAME_NOT_FOUND |
  :INVALID_CARD |
  :CARD_NOT_FOUND |
  :EXCHANGE_LIMIT_EXCEEDED |
  :VALIDATION_ERROR |
  :UNKNOWN_COMMAND |
  :INVALID_SELECTION |
  :NO_CARDS_LEFT

type in_game_command = Commands::ExchangeCard | Commands::EndGame


interface _Command
  def class: () -> untyped
  def nil?: () -> bool
  def is_a?: (Class) -> bool
  def game_number:() -> GameNumber?
end

module Commands
  class GameStart
    include _Command
    def initialize: () -> void
  end

  class ExchangeCard
    include _Command
    attr_reader discarded_card: HandSet::Card
    def initialize: (HandSet::Card, GameNumber) -> void
  end

  class EndGame
    include _Command
    def initialize: (GameNumber) -> void
  end
end

module CommandErrors
  class VersionConflict
    attr_reader expected_version: Integer
    attr_reader actual_version: Integer
    def initialize: (Integer, Integer) -> void
  end

  class InvalidCommand
      GAME_NOT_IN_PROGRESS: command_error_code
      GAME_ALREADY_ENDED: command_error_code
      GAME_NOT_FOUND: command_error_code
  
      INVALID_CARD: command_error_code
      CARD_NOT_FOUND: command_error_code
      EXCHANGE_LIMIT_EXCEEDED: command_error_code
  
      VALIDATION_ERROR: command_error_code
  
      UNKNOWN_COMMAND: command_error_code
      INVALID_SELECTION: command_error_code
      NO_CARDS_LEFT: command_error_code
  
      attr_reader command: _Command
      attr_reader message: String
      attr_reader error_code: command_error_code
      
      def initialize: (command: _Command, error_code: command_error_code) -> void
  end
end

interface _CommandHandler
  def initialize: (EventBus) -> void
  def handle: (_Command) -> CommandResult
  def append_to_aggregate_store: (_Event, _Command) -> CommandResult

end


module CommandHandlers
  class GameStart
    include _CommandHandler

    private
    attr_reader start_command: Commands::GameStart
    attr_reader event_bus:  EventBus
    attr_reader aggregate_store: Aggregates::Store
    def append_event_to_store!: (HandSet initial_hand) -> CommandResult
  end

  class InGame
    include _CommandHandler

    private
    attr_reader event_bus:  EventBus
    attr_reader aggregate_store: Aggregates::Store
    attr_reader command: in_game_command
    attr_accessor executor: _InGameExecutor

    def append_event_to_store!: () -> CommandResult

    def build_executor: -> _InGameExecutor

  end

  interface _InGameExecutor
    def initialize: () -> void

    def operate_board: (Aggregates::BoardAggregate) -> void

    def build_event: (in_game_command) -> _Event
  end

  module InGameExecutor
    class ExchangeCard
      include _InGameExecutor

      private
      attr_reader new_card: HandSet::Card
    end

    class EndGame
      include _InGameExecutor
    end
  end

  class EndGame
    include _CommandHandler

    private
    attr_reader event_bus:  EventBus
    attr_reader aggregate_store: Aggregates::Store
    attr_reader end_game_command: Commands::EndGame

    def append_event_to_store!: () -> CommandResult
  end

  class ErrorResultBuilder
    def self.build_error_if_needed: (_Command, Aggregates::BoardAggregate, Aggregates::Store) -> CommandResult?

    private
    def self.build_card_not_found_error_code_if_needed:(Commands::ExchangeCard, Aggregates::BoardAggregate, Aggregates::Store) -> command_error_code?
    def self.rebuild_hand_from_event: (Aggregates::BoardAggregate, Array[HandSet::Card], _Event) -> Array[HandSet::Card]
    def self.build_error_code_of_game_status_if_needed: (_Command, Aggregates::BoardAggregate, Aggregates::Store) -> command_error_code?
    def self.build_error_code_of_hand_state_in_hand_if_needed: (_Command, Aggregates::BoardAggregate, Aggregates::Store) -> command_error_code?
    def self.raise_if_invalid_error_code:(command_error_code) -> void
  end
end

module Aggregates
  class Store


    def next_available_version_for_game: (GameNumber?) -> Integer
    def current_version_for_game: (GameNumber?) -> Integer
    def exists_game?: (GameNumber?) -> bool
    def game_ended?:(GameNumber?) -> bool
    def game_in_progress?: (GameNumber?) -> bool
    def append_event: (_Event, GameNumber?) -> CommandResult
    def append_initial_event: (_Event, GameNumber?) -> CommandResult
    def load_all_events_in_order: (GameNumber?) -> Array[_Event]
    def latest_event: () -> _Event?
    def load_board_aggregate_for_current_state: (GameNumber?) -> Aggregates::BoardAggregate
    def build_board_aggregate: () -> Aggregates::BoardAggregate

    private
    def persist_and_finalize_event: (_Event, GameNumber?) -> CommandResult
    def valid_event_type?: (_Event | CommandErrors::InvalidCommand | CommandErrors::VersionConflict) -> bool
    def create_event_record!: (_Event, GameNumber?) -> Event

    class EventBuilder
      MAPPINGS: Hash[String, untyped]

      def self.execute: (Event event_record) -> _Event

      private
      def self.raise_if_invalid_event_record: (Event event_record, Hash[String, untyped] maps) -> void
      def self.build_event: (Event event_record, Hash[String, untyped] maps) -> _Event
      def self.valid_event_type?: (untyped) -> bool
    end

    class ErrorResultBuilder
      def self.version_conflict: (GameNumber?, Integer) -> CommandResult
      def self.validation_error: (ActiveRecord::RecordInvalid, _Command) -> CommandResult
    end
  end

  class BoardAggregate
    attr_reader game_number: GameNumber?

    # 一時的に
    attr_reader deck: Deck
    attr_reader current_hand_set: HandSet?


    def initialize:(game_number: GameNumber?) -> void

    def apply: (_Event event) -> void
    def draw_initial_hand: () -> HandSet
    def draw: () -> HandSet::Card
    def drawable?: () -> bool
    def remaining_deck_count: () -> Integer
    def current_hand_cards: () -> Array[HandSet::Card]
    def card_in_deck?: (HandSet::Card) -> bool

    def empty_trash?: -> bool

    def finish_game: () -> nil
    def build_cards_from_exchanged_event: (Array[HandSet::Card], CardExchangedEvent) -> Array[HandSet::Card]
    def game_in_progress?: () -> bool
    def game_ended?: () -> bool
    def exists_game?: () -> bool
  
    private
    attr_reader game_started: bool
    def build_cards_from_event: (GameStartedEvent) -> Array[HandSet::Card]
  end

  class Deck
    attr_reader cards: Array[HandSet::Card]
    def draw_initial_hand: () -> HandSet
    def draw: () -> HandSet::Card
    def remove: (HandSet::Card card) -> void
    def has?: (HandSet::Card card) -> bool

    def remaining_count: () -> Integer
  
    private
    def generate_initial_cards: () -> Array[HandSet::Card]
  end

  class Trash
    attr_reader cards: Array[HandSet::Card]
    def accept: (HandSet::Card card) -> void
  end
end

class CommandResult
  attr_reader event: _Event?

  type command_result_error = CommandErrors::InvalidCommand | CommandErrors::VersionConflict

  attr_reader error: (command_result_error)?
  def initialize: (?event: _Event?, ?error: command_result_error?) -> void
  def success?: () -> bool
  def failure?: () -> bool
  def self.invalid_command: (_Command, command_error_code) -> CommandResult
end

class CommandBus
  def initialize: (EventBus, Logger) -> void
  def execute: (_Command) -> CommandResult
  private
  type command_class = singleton(Commands::GameStart) | singleton(Commands::EndGame) | singleton(Commands::ExchangeCard)
  type command_handler = CommandHandlers::GameStart | CommandHandlers::EndGame | CommandHandlers::InGame


  def build_handler_map: () -> Hash[command_class, command_handler]
  def log_error_if_needed: (untyped) -> void
  attr_reader event_bus: EventBus
  attr_reader logger: Logger
end