interface _EventSubscriber
  def handle_event: (_Event event) -> void
end


class Projection
  include _EventSubscriber
end


module ReadModels
  class PlayerHandState
    def initialize: () -> void
    def start_new_game!: (SuccessEvents::GameStarted) -> void
    def exchange_card!: (SuccessEvents::CardExchanged) -> void
    def end_game!: (SuccessEvents::GameEnded) -> void
    def current_state_for_display: () -> { status: String, hand: String, current_rank: String, rank_name: String, turn: Integer }
    def hand_set: () -> HandSet
    def refreshed_hand_set: () -> HandSet
  end

  class Histories
    def self.load: (?limit: Integer) -> Array[Query::History]
    def self.add: (HandSet hand_set) -> Query::History
  end
end

interface _CardForQuery
  include _Card
end 

class EventPublisher
  def initialize: (projection: Projection, event_listener: LogEventListener) -> void
  def subscribe: (Projection | LogEventListener) -> void
  def broadcast: (String, _Event) -> void
  attr_reader published_events: Array[_Event] 
end 

####################
# privateメソッド定義
####################

class Projection
  private
  def apply_to_player_hand_state: (ReadModels::PlayerHandState player_hand_state, _Event event) -> void
end

module ReadModels
  class PlayerHandState
    private
    attr_reader player_hand_state: Query::PlayerHandState
    def format_hand: () -> String
  end
end

class LogEventListener
  private
  def logger: () -> Logger
  def format_event_message: (String?, ?String) -> String
  def format_cards: (Array[String]) -> String
  def build_info_message: (_Event event) -> String
  def build_warning_message_if_needed: (_Event event) -> String?
end

class EventPublisher
  private
  attr_reader projection: Projection
  attr_reader event_listener: LogEventListener
end 