---
description: 
globs: 
alwaysApply: true
---
# ボブくん学習帳
これはボブくんが新しいことを教わったときに書くものです

## 📝 学習記録テンプレート
各トピックは以下の形式で記録します：
- タイトルは `##` で始め、適切な絵文字を付けます
- 学んだ要点は箇条書きで簡潔に記載
- コード例がある場合は Good/Bad パターンを含めます

## 🧪 テストの構造化：aggregate_failuresの適切な使い方

### 📌 学んだことの要点
- aggregate_failuresブロックは検証（expect）のみを含めるべき
- 準備（setup）と実行（execution）は外側に配置する
- これにより、テストの意図と実行の流れが明確になる

### 🧪 具体例（コード・状況など）
```ruby
# ✅ Good：準備と実行は外側、検証は内側
it 'ゲームが正しく開始されること' do
  # 準備と実行
  command = GameStartCommand.new
  command_handler.handle(command)

  # 検証
  aggregate_failures do
    expect(logger.messages_for_level(:info)).to include(/イベント受信: ゲーム開始/)
    expect(GameState.last.status).to eq('started')
  end
end

# ❌ Bad：準備や実行もaggregate_failuresの中に含めている
it 'ゲームが正しく開始されること' do
  command = GameStartCommand.new

  aggregate_failures do
    command_handler.handle(command)  # 実行をブロック内に入れてしまっている
    expect(logger.messages_for_level(:info)).to include(/イベント受信: ゲーム開始/)
    expect(GameState.last.status).to eq('started')
  end
end

# ❌ Bad：検証が外側にもある
it 'ゲームが正しく開始されること' do
  command = GameStartCommand.new
  command_handler.handle(command)
  expect(command).to be_valid  # 検証が外側にある

  aggregate_failures do
    expect(logger.messages_for_level(:info)).to include(/イベント受信: ゲーム開始/)
    expect(GameState.last.status).to eq('started')
  end
end
```

## 🧪 テストダブルの使用制限

### 学んだこと
- テストダブル（TestクラスやMockオブジェクト）は、学習目的で実装方法を記録する場合を除いて作成しない
- 他に手段がない場合に限り、本物のクラスを使用する

### 理由
- より実際の動作に近いテストができる
- 実装の変更に対してテストが壊れにくくなる
- テストコードがより信頼性の高いものになる

### 例
```ruby
# ❌ Bad：安易にテスト用のクラスを作成おか
class TestEventListener
  def handle_event(event)
    @received_events << event
  end
end

# ✅ Good：本物のクラスを使用
let(:event_listener) { LogEventListener.new }
```

### 例外
- 学習記録として実装パターンを残す場合
- フレームワークやライブラリが提供するテストダブル（RSpecのdouble等）


RSpecのsubject活用パターン
学んだこと
subjectはテスト内で「Act（実行）」の共通化や、テストの可読性向上に役立つ
名前をつけずに無名のsubjectとして使うのが基本（subject { ... }）
contextごとにsubjectを再定義することで、テストのArrange-Act-Assertが明確になる
letやbeforeとの使い分けも意識し、テストの意図が伝わる構造にする
例
Apply to lessons.mdc
end
ポイント
subjectは「テストごとの主役（Act）」として使う
使い方を統一することで、テストの意図が明確になり、可読性・保守性が向上する
名前付きsubjectも使えるが、無名のsubjectが推奨される

## 🧪 RSpecでsubject/let/contextを活用したテスト設計のベストプラクティス

- subjectを「コマンドの実行結果」など共通の振る舞いで統一することで、テストの重複を減らせる
- let(:card)などの引数をcontextごとに切り替えることで、正常系・異常系を同じsubjectで柔軟にテストできる
- context/let/subject/itの責務が明確になり、テストの可読性・保守性が大きく向上する
- RSpecらしい自然な構造になり、テストの意図が伝わりやすい

```ruby
subject { command_handler.handle(Command.new, CommandContext.build_for_exchange(card)) }

context '正常系' do
  let(:card) { Card.new(current_hand.first) }
  it 'CardExchangedEventが発行されること' do
    expect(subject).to be_a(CardExchangedEvent)
  end
end

context '異常系（手札に存在しないカード）' do
  let(:card) { Card.new('♠A') }
  it 'InvalidCommandEventが発行されること' do
    expect(subject).to be_a(InvalidCommandEvent)
  end
end
```
```

## 🧪 letの最小化と依存関係のまとめ方（RSpecベストプラクティス）

- letは「本当に複数のexampleで使うもの」「テスト全体で何度も参照するもの」だけに限定する
- 依存関係がある場合は、letの中でローカル変数としてまとめて定義する
- 使い捨ての値や一時的なオブジェクトはletではなくローカル変数で十分
- letの乱用を避けることで、テストの可読性・保守性が向上する

### 例

```ruby
# ✅ Good: 依存関係をletの中でまとめる
let(:log_event_listener) do
  logger = TestLogger.new
  LogEventListener.new(logger)
end

# ❌ Bad: 使い捨ての値までletで定義してしまう
let(:logger) { TestLogger.new }
let(:log_event_listener) { LogEventListener.new(logger) }
```

### ポイント

- letの数は最小限に
- 依存関係はletの中でローカル変数としてまとめる
- テストの可読性・保守性が高まる