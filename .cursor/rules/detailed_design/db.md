# データベース設計 最終更新日 2025/03/02



## 1. テーブル設計

### **EventStore（イベントストア）**

イベントソーシングを採用するため、状態の変化をイベントとして記録する。

| カラム名     | 型        | 説明 |
|-------------|----------|------|
| id          | BIGSERIAL | 主キー、自動採番 |
| event_type  | TEXT     | イベントの種類 (GameStarted, CardExchanged, GameEnded など) |
| event_data  | JSONB    | イベントの詳細データ |
| occurred_at | TIMESTAMP | イベントが発生した時間 |

**ポイント：**
- `event_data` は JSONB 型を使用し、イベントごとに柔軟なデータ構造を持たせる。
- `occurred_at` によってイベントの時系列順を保証。

---

### **GameState（リードモデル）**

リードモデルは `EventStore` のデータを集約し、ゲームの最新状態を効率的に取得できるようにする。

| カラム名 | 型  | 説明 |
|---------|-----|------|
| game_id | UUID | ゲームの一意識別子 |
| hand_1  | TEXT | 1枚目の手札 |
| hand_2  | TEXT | 2枚目の手札 |
| hand_3  | TEXT | 3枚目の手札 |
| hand_4  | TEXT | 4枚目の手札 |
| hand_5  | TEXT | 5枚目の手札 |
| rank    | TEXT | 現在の役（ONE PAIR, STRAIGHT など） |

**ポイント：**
- `hand_1 ~ hand_5` を個別カラムにすることで、NULL の管理や可変長リストを考えなくて済む。
- `rank` には現在の役を文字列で保存し、検索を容易にする。
- `game_id` を主キーとし、各ゲームの状態を一意に識別。

---

## 2. データ設計の考え方

### **イベントストアとリードモデルの分離**
- `EventStore` は **変更履歴を全て記録** し、過去の状態を再現できる。
- `GameState` は **最新状態を高速に取得するための最適化**。

### **リードモデルを正規化しない理由**
- 5枚の手札を持つことが **ルールとして決まっている** ため、正規化するメリットが少ない。
- クエリのシンプルさとパフォーマンスを優先するため、JSONB ではなくカラムを分けた設計。

---

## 3. データの更新フロー

1️⃣ **コマンドが発行される**
   - 例: `ExchangeCard(oldCard: Card, newCard: Card)`
2️⃣ **イベントが `EventStore` に保存される**
   - 例: `CardExchanged` イベントが記録される。
3️⃣ **リードモデル (`GameState`) を更新**
   - `EventStore` を元に `hand_1 ~ hand_5` のデータを更新。
