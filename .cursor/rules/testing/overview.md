# テスト概要ガイドライン

## 基本方針
- テストファーストで開発を進める
- 単体テスト、統合テスト、E2Eテストをバランスよく配置
- テストカバレッジは80%以上を目指す
- 小さなステップで進める
  - 一度に大きな変更を加えない
  - 各ステップで動作確認ができる状態を維持する
- 外から内へ実装を進める
  - インターフェース層から始める
  - ユースケース層、ドメイン層の順に実装する
  - 各層で適切なテストを書く
- モックの使用を最小限に抑える
  - 原則として実際のオブジェクトを使用する
  - 外部サービスなど、どうしても必要な場合のみモックを使用
  - モックを使う場合は、そのリスクを認識して慎重に判断する

## テストの書き方の原則

### 振る舞いに焦点を当てる
- メソッドの呼び出しを検証するのではなく、振る舞いの結果を検証する
- 「何が起きたか」を検証し、「どのように起きたか」には依存しない
- 振る舞いのテストは実装の変更に強く、リファクタリングしても壊れにくい
- モックやスタブは必要な場合のみ使用し、過剰な使用は避ける

### 実装との依存関係
- テストコードは実装の定数や設定を直接参照すべき
- 理由：
  - 実装と仕様の一致を保証できる
  - 変更の影響範囲が明確
  - メンテナンスが容易
  - テストは実装が仕様を満たしているかを確認する役割
- 例外：
  - モック/スタブでの値の定義
  - テスト固有の設定値
  - 実装から独立させたい特殊なケース

### テスト用ダミークラスの定義場所
- テストで使用するダミークラス（モック、スタブなど）は、テストケースの直下に定義する
- メリット：
  - 可読性: テストに関連するすべてのコードが一箇所にまとまる
  - 名前空間の汚染防止: グローバル名前空間を汚染せず、他のテストとの衝突を防ぐ
  - テストの独立性: 各テストが必要なダミークラスを自身で定義するため、テスト間の依存関係が減少
  - メンテナンス性: テストを修正する際に、関連するダミークラスも同時に見直せる
- 例外：
  - 複数のテストで共有する必要があるダミークラスは、`spec/support`ディレクトリに配置
  - 大規模なダミークラスは、可読性のために別ファイルに分離することも検討

## ActiveRecordモデルのテスト方針
- ActiveRecordモデルは原則としてFactoryBotを使用して生成する
- 例外的なケースを除き、テスト内での直接のインスタンス生成は避ける
- バリデーションやスコープなどのモデルの振る舞いに焦点を当てる
- データベースの状態に依存するテストは、適切にセットアップとティアダウンを行う

## ドメインオブジェクトのテスト方針
- 外部依存を持つ場合は適切にモック化
- 値オブジェクトは等価性のテストを重視

## コントローラーのテスト方針
- リクエストスペックを中心に実装
- レスポンスのステータスコードと内容を検証
- 認証・認可のテストを含める


## テストデータの作成方針

### FactoryBotの使用
- 原則として`build`を使用し、必要な場合のみ`create`を使用する
  - `build`: DBに保存せずにインスタンスを作成（高速）
  - `create`: DBに保存してインスタンスを作成（低速）
- `create`を使用するケース：
  - 関連オブジェクトの取得が必要な場合
  - DBに依存する機能をテストする場合
  - バリデーションが外部キー制約に依存する場合
- パフォーマンスを意識し、不必要なDB操作を避ける
- テスト実行速度の向上のため、可能な限り`build_stubbed`も検討する

## テストコードの書き方

### コメントの使用

テストコードでは、以下のガイドラインに従ってコメントを使用してください：

1. **コードの内容を説明するコメントは避ける**
   - 悪い例: `# ハンドラを登録する`、`# イベントを発行する`
   - 理由: コードが何をしているかは、コード自体から明らかであるべき

2. **コメントが必要な場合は「なぜ」そのコードが存在するのかを説明する**
   - 良い例: `# ActiveSupport::Notificationsの仕様により、購読解除が必要`
   - 理由: コードの意図や背景知識を提供する

3. **テストの意図は、テストメソッド名で明確にする**
   - 良い例: `it 'イベントが正しく発行され、ログが出力されること'`
   - 理由: テストの目的が明確になる

4. **テストの構造を「準備（Arrange）→実行（Act）→検証（Assert）」のパターンに従う**
   - 準備: テスト対象のオブジェクトやモックの設定
   - 実行: テスト対象のメソッドを呼び出す
   - 検証: 期待する結果を確認する

5. **複雑なテストセットアップには、ヘルパーメソッドやファクトリを使用する**
   - 理由: テストコードの可読性と再利用性が向上する

### 良いテストコードの例

```ruby
RSpec.describe Notification do
  # テスト用のダミークラス
  class DummyEvent    
    def to_h
      { test: 'data' }
    end
    
    def self.name
      'dummy_event'
    end
  end
  
  class DummyHandler
    attr_reader :received_event
    
    def handle(event)
      @received_event = event
    end
  end
  
  describe 'プレイヤー行動通知のテスト' do
    it 'イベントが正しく発行され、ログが出力されること' do
      # 準備（Arrange）
      logger_mock = double('logger')
      allow(Rails).to receive(:logger).and_return(logger_mock)
      expect(logger_mock).to receive(:info).with(/プレイヤー行動ハンドラ登録/).at_least(:once)
      
      handler = DummyHandler.new
      
      # 実行（Act）
      subscription = described_class.register_player_action_handler('dummy_event', handler)
      event = DummyEvent.new
      described_class.notify_player_action(event)
      
      # 検証（Assert）
      expect(handler.received_event).to be_a(DummyEvent)
      
      # クリーンアップ
      ActiveSupport::Notifications.unsubscribe(subscription)
    end
  end
end
```

このテストコードは、コメントがなくても理解しやすく、テストの意図が明確です。必要に応じて「準備→実行→検証」の構造を示すコメントを入れることは許容されますが、各ステップで何をしているかを説明するコメントは避けてください。 