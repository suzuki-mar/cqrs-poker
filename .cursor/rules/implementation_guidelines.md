# 実装ガイドライン

## 二重管理の回避

### 原則
- 同じ情報を複数の場所で管理することを避ける
- 情報は一箇所で定義し、必要に応じて参照する
- ドキュメントとコードの整合性を保つため、自動生成を活用する

### 具体的な実践方法

#### ドキュメント管理
- ディレクトリ構造を自己説明的にする
  - 例: `.cursor/rules/testing/` 配下にテスト関連のドキュメントを配置
- ファイル名で内容を明確にする
  - 例: `overview.md`, `practices.md`, `examples.md`
- READMEなどの目次ファイルは作成しない
  - 理由: ファイル変更のたびに更新が必要になり、管理コストが高い
  - 代わりに: ディレクトリ構造とファイル名で内容を表現する

#### コード管理
- 定数や設定値は一箇所で定義
  - 例: `VALID_RANKS = ['HIGH_CARD', 'ONE_PAIR', ...]` はモデルに定義し、テストからは参照する
- 共通ロジックはヘルパーやサービスに抽出
  - 例: 複数のコントローラで使用する認証ロジックは `AuthenticationService` に抽出
- 重複するテストデータはファクトリに定義
  - 例: `FactoryBot.define { factory :user do ... end }`

#### API仕様
- OpenAPI/Swaggerなどを使用して一元管理
- コードからAPI仕様を自動生成する仕組みを導入
- 手動でAPI仕様書を更新しない

#### データベーススキーマ
- マイグレーションファイルを正として扱う
- `schema.rb` は自動生成されるものとして扱い、直接編集しない
- ERDは必要に応じて `schema.rb` から自動生成

### 二重管理が許容されるケース
- パフォーマンス上の理由がある場合
  - 例: キャッシュとしてのデータの複製
- システム間の連携で避けられない場合
  - 例: 外部システムとのデータ同期
- 明確な責任分担がある場合
  - 例: フロントエンドとバックエンドでの型定義

### 二重管理を発見した場合の対応
1. 情報の正しい「正」を特定する
2. 他の場所での定義を参照に変更する
3. 自動化できる部分は自動化する
4. やむを得ず二重管理する場合は、その理由をコメントで明記する 