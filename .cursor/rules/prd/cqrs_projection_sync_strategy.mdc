---
description: 
globs: 
alwaysApply: false
---
# 📘 PRD: CQRS+ES における Projection 処理方式の選定方針

## 1. 背景

本プロジェクトでは、CQRS + Event Sourcing アーキテクチャを採用しており、**Projection（読み取りモデル）の更新方式**として「同期」または「非同期」のいずれかを選定する必要がある。  
本ドキュメントでは、それぞれの特徴を整理した上で、初期リリースにおける選択とその理由を明確にする。

---

## 2. 選択肢比較：同期 vs. 非同期

| 項目 | 同期（Sync） | 非同期（Async） |
|------|----------------|-------------------|
| **Query更新のタイミング** | コマンド実行直後、Projection が即時適用される | イベント発行後、別プロセスで Projection が適用される |
| **Commandの処理速度** | Projection完了まで待機 → 実行時間が長くなる可能性 | イベント発行のみで完了 → 高速に完了 |
| **設計の複雑さ** | 単純でデバッグしやすい | ジョブ処理やリトライ管理などが必要 |
| **データ一貫性** | 強い一貫性（Queryが常に最新） | 最終的な一貫性（反映まで遅延あり） |
| **適したユースケース** | 小規模・デモ・履歴確認重視 | 大規模・通知/分析分離・スケーラビリティ要求あり |
| **実装例** | `CommandHandler` 内で `Projection.apply(event)` | `ProjectionJob.perform_later(event)` 等で非同期呼び出し |

---

## 3. 採用方針

### ✅ 初期リリースにおける方針：**同期 Projection を採用する**

---

## 4. 採用理由（まーさんの判断基準）

### 4.1 実装のシンプルさとデバッグ性を優先
- 複雑な非同期処理を入れる前に、**まずは正しく動作するデモを完成させることを重視**
- 同期方式であれば、**Projectionの結果がすぐ確認でき、状態の追跡やエラー検知がしやすい**

### 4.2 目的はスケーラビリティより「履歴の再構成性」
- 今回の主目的は「大量トラフィックへの対応」ではなく、  
  **「イベント記録に基づく `GameState` の復元」**
- **Projection の即時反映により、確定的かつ一貫した動作を保証できる**

### 4.3 CLIベースのUIに即時反映がフィット
- 本プロダクトはCLIベースで操作されるため、**ユーザーの入力 → 状態反映の即時性** が重要
- 非同期反映では、**操作直後に画面に反映されない等の体験ギャップが生じる懸念**がある

### 4.4 非同期への切り替えは将来的に対応可能
- ActiveJob や EventBus の設計を考慮しておけば、**非同期 Projection への切り替えは後からでも可能**
- 現時点では同期で構築し、**必要になったときに段階的に非同期化**する方が安全で柔軟性も高い

---

## 5. 今後の方針

- **スケーラビリティや他サービス連携が必要になったタイミングで非同期化を検討**
- 非同期対応時は、次の要件を同時に設計する：
  - イベントのリトライ戦略
  - 並行処理における冪等性の保証
  - Query側キャッシュと整合性の設計

---

### ✅ 結論
> 初期リリースでは「同期方式」を採用し、明快な状態遷移と履歴管理を優先する。  
> 非同期化はスケーラビリティが求められる段階での段階的導入を想定する。
