---
description: 学習帳にかいてといったらフォーマットに従って書く
globs: 
alwaysApply: false
---
# ボブくん学習帳
これはボグくんが新しいことを教わったときに書くものです

## 📌 学んだことの要点
- 短く、何を学んだかを書く（例：責務を分離する設計が保守性を上げる）

## 🧪 具体例（コード・状況など）
```ruby
# ここにサンプルコードや実際の状況を書く
```

## テスト実行ルール
テストを実行する際は、必ず最近編集したファイルに関連するテストだけを実行する。
例: 最近編集したファイルがapp/domains/event_store_domain.rbの場合、spec/domains/event_store_domain_spec.rbのテストを実行する。

## 設計原則
### YAGNI (You Aren't Gonna Need It)
必要になるまで機能を実装しない原則。将来必要になるかもしれないという理由だけで機能を実装すると、無駄な複雑さが増し、メンテナンスコストが高くなる。

例: `GameStateDomain`クラスで、現時点で必要ない`exchange_cards`メソッドを実装せず、必要になった時点で追加する。

これにより：
- コードがシンプルになる
- 開発速度が上がる
- 不要な機能のバグやメンテナンスコストを避けられる

### 責務の分離
各クラスは明確に定義された単一の責務を持つべきという原則。特に、ドメインロジックとデータアクセスの責務は分離すべき。

例: `GameState`モデル（ActiveRecord）にドメインロジックを漏らさず、`GameStateDomain`クラスがドメインオブジェクト（`Hand`）とデータモデルの間の変換を担当する。

これにより：
- コードの凝集度が高まる
- 変更の影響範囲が限定される
- テストが容易になる
- ドメインモデルの純粋性が保たれる

### コードの簡潔さ
コードは可能な限り簡潔に保ち、不要な複雑さを避けるべき。特に、不要なコメントや説明的な変数名は避け、コード自体が自己説明的であるようにする。

例: `GameStateDomain`クラスから不要なメソッドやコメントを削除し、必要最小限のコードだけを残す。

これにより：
- コードの可読性が向上する
- メンテナンスが容易になる
- バグの発生確率が減少する
- 新しい開発者がコードを理解しやすくなる

### 実装の優先順位
全体の設計や将来の拡張性が見えていても、現在必要な機能だけを実装することを優先する。

例: `Hand`クラスで、現時点で不要な値オブジェクトとしての機能（`==`や`hash`メソッド）を実装せず、必要になった時点で追加する。

これにより：
- 本当に必要な機能に集中できる
- コードがシンプルに保たれる
- 不要な複雑さが入り込むのを防げる
- 実際の要件に基づいた設計ができる

### Railsにおけるリポジトリパターンの使用
Railsでは、ActiveRecordを直接利用するのが一般的で、リポジトリパターンを使わないことが推奨されます。ActiveRecordは既にデータアクセス層を抽象化しており、リポジトリパターンを導入すると冗長になりがちです。また、Railsのエコシステムから大きく外れてしまうと、Railsが提供する多くの便利な機能やGemの恩恵を受けられなくなる可能性があります。

これにより：
- コードの簡潔さが保たれる
- ActiveRecordの機能を最大限に活用できる
- 開発速度が向上する
- メンテナンスが容易になる
- Railsのエコシステムからの恩恵を最大限に受けられる

### RailsWayとエコシステムのバランス
Railsで開発する際は、RailsWayに従いすぎず、エコシステムの恩恵を受けることが重要です。RailsWayは強力なガイドラインを提供しますが、プロジェクトの要件によっては柔軟に対応する必要があります。ただし、Railsのエコシステムから大きく外れると、多くの便利な機能やGemの恩恵を受けられなくなる可能性があるため、バランスを取ることが重要です。

これにより：
- Railsの強力な機能を最大限に活用できる
- プロジェクトの要件に応じた柔軟な設計が可能になる
- 開発速度が向上する
- メンテナンスが容易になる
- Railsのエコシステムからの恩恵を最大限に受けられる

## テスト戦略
### ドメインクラスのテスト
ドメインクラスは、実際のデータベース更新をテストすべき。モックやスタブを使わず、実際のデータベースを使用することで、より現実的なテストになる。

例: `GameStateDomain`クラスのテストでは、`GameState`のモックを使わず、実際にデータベースに保存されたデータを検証する。

これにより：
- 実際のアプリケーションの動作に近いテストができる
- データベースとの連携に関する問題を早期に発見できる
- 統合テストの要素を持ち、より信頼性の高いテストになる

## 設計原則

### キーワード引数の活用
キーワード引数を使うことで、メソッドの呼び出し時に引数の意味が明確になり、コードの可読性が向上します。特に、必須のキーワード引数を使うことで、呼び出し側で明示的に引数を指定する必要があり、意図しない`nil`の渡し忘れを防ぐことができます。

例: `EventBus`の初期化メソッドで、`event_listener:`を必須のキーワード引数として指定する。

```ruby
event_bus = EventBus.new(event_listener: event_listener)
```

これにより：
- 呼び出し側で`event_listener:`を明示的に指定する必要がある
- `nil`が渡されることを防ぐ
- メソッドの引数の意味が明確になり、コードの可読性が向上する
- 将来的に他の引数を追加する際に、引数の順序を気にする必要がなくなる

### Domainクラスの使用
Domainクラスを使うことで、ビジネスロジックをモデルから分離し、コードの可読性や保守性が向上します。特に、複雑なビジネスロジックを扱う場合、Domainクラスを使用することで、モデルがシンプルに保たれ、テストが容易になります。

これにより：
- ビジネスロジックが明確になる
- モデルがシンプルに保たれる
- テストが容易になる
- コードの可読性が向上する
- 保守性が向上する

### Domainクラスのインターフェース
Domainクラスのインターフェース（メソッドなど）は、Railsに依存しない形で設計することが重要です。これにより、Domainクラスがフレームワークに依存せず、ビジネスロジックに集中できるようになります。

これにより：
- フレームワークへの依存を排除できる
- テストが容易になる
- 再利用性が向上する
- ビジネスロジックが明確になる

### ARモデルとドメインロジックの分離
ActiveRecord（AR）モデルにドメインロジックを実装すると、単一責任の原則（SRP）に違反してしまいます。ARモデルはデータの永続化に集中すべきで、ビジネスロジックはDomainクラスに分離することが重要です。

これにより：
- 責務が明確になる
- コードが簡潔になる
- テストが容易になる
- 再利用性が向上する

### Domainクラスによる「どこに書けばいいか問題」の解消
Domainクラスを使うことで、ビジネスロジックをどこに書けばいいかという問題が解消されます。これにより、コードの可読性と保守性が向上し、開発者が迷うことなく適切な場所にロジックを記述できるようになります。

これにより：
- 責務が明確になる
- コードが整理される
- 開発者の迷いが解消される
- 保守性が向上する

### 簡単なシステムでもARに書くと問題になる
簡単なシステムだからといって、ActiveRecord（AR）にビジネスロジックを書いてしまうと、将来的に大きな問題を引き起こす原因になります。これにより、コードの可読性と保守性が低下し、システムの拡張が困難になります。

これにより：
- 責務が混在する
- コードが複雑になる
- テストが困難になる
- 拡張性が低下する
