# Testing Strategy

## 基本方針

1. 小さなステップで進める
   # 例: Rakeタスクの実装
   # 1. まずRakeタスクが実行できることを確認
   # 2. 次にUseCaseを呼び出せることを確認
   # 3. その後、UseCaseの中身を実装
   - 一度に大きな変更を加えない
   - 各ステップで動作確認ができる状態を維持する

2. テストファーストで実装する
   # 例: StartGameUseCaseの実装
   # 1. UseCase実行のテストを書く
   # 2. 最小限のUseCaseクラスを実装
   # 3. 機能を少しずつ追加していく
   - まず失敗するテストを書く
   - テストが通る最小限の実装を行う
   - 必要に応じてリファクタリングする

3. 外から内へ実装を進める
   # 例: ポーカーゲームの実装順序
   # 1. Rakeタスク（外部インターフェース）
   # 2. StartGameUseCase（アプリケーション層）
   # 3. Game, Card, Handクラス（ドメイン層）
   - インターフェース層から始める
   - ユースケース層、ドメイン層の順に実装する
   - 各層で適切なテストを書く

4. スパイクテストの活用
   # 例: CLIインターフェースの実装
   # 1. まずスパイクテストでUIを確認
   # 2. 得られた知見を元に本実装の設計を決定
   # 3. TDDで本実装を進める
   - 実験的な実装が必要な場合はスパイクテストを使用
   - スパイクで得た知見を本実装に活かす

5. モックの使用を最小限に抑える
   # モックを使うと：
   # - 実際の動作と異なる振る舞いをテストしてしまう可能性がある
   # - 実装の詳細にテストが依存してしまう
   # - リファクタリング時にテストの修正が必要になる
   - 原則として実際のオブジェクトを使用する
   - 外部サービスなど、どうしても必要な場合のみモックを使用
   - モックを使う場合は、そのリスクを認識して慎重に判断する

6. テストの出力を最小限に
   # デバッグ目的の出力は：
   # - テストの意図を不明確にする
   # - CIでのログを冗長にする
   # - 他の重要なエラーメッセージを見づらくする
   - テストでは不要な出力（puts等）を含めない
   - デバッグが必要な場合は一時的な使用に留める
   - テスト結果の判定は出力ではなく、アサーションで行う

7. 実装との依存関係
   # テストコードは実装の定数や設定を直接参照すべき
   # 例: GameStateのバリデーション
   # - ❌ テストで独自に定数を定義
   #     VALID_RANKS = ['HIGH_CARD', 'ONE_PAIR', ...]
   # - ✅ 実装の定数を参照
   #     it { should validate_inclusion_of(:current_rank).in_array(GameState::VALID_RANKS) }
   
   理由：
   - 実装と仕様の一致を保証できる
   - 変更の影響範囲が明確
   - メンテナンスが容易
   - テストは実装が仕様を満たしているかを確認する役割

   例外：
   - モック/スタブでの値の定義
   - テスト固有の設定値
   - 実装から独立させたい特殊なケース
